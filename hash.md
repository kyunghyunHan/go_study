# π‘©π»β€π“ν•΄μ‹ 
Go μ–Έμ–΄μ—μ„λ” ν•΄μ‹, λ€μΉ­ν‚¤ μ•κ³ λ¦¬μ¦, κ³µκ°ν‚¤ μ•κ³ λ¦¬μ¦μ„ λΉ„λ΅―ν•΄ λ‹¤μ–‘ν• μ•”νΈν™” μ•κ³ λ¦¬μ¦μ„ ν¨ν‚¤μ§€λ΅ μ κ³µν•©λ‹λ‹¤. λ³΄ν†µ μ•”νΈν™” μ•κ³ λ¦¬μ¦μ€ νμΌμ„ μ•”νΈν™”ν•κ±°λ‚, λ„¤νΈμ›ν¬λ΅ λ°μ΄ν„°λ¥Ό μ£Όκ³  λ°›μ„ λ• λ°μ΄ν„°λ¥Ό λ³΄νΈν•κΈ° μ„ν•΄ μ‚¬μ©ν•©λ‹λ‹¤.

- ν•΄μ‹(Hash) μ•κ³ λ¦¬μ¦: MD5, SHA1, SHA256, SHA512 λ“±μ΄ μμΌλ©° λ°μ΄ν„°μ—μ„ κ³ μ ν• ν•΄μ‹ κ°’μ„ μ¶”μ¶ν•΄λƒ…λ‹λ‹¤. μ΄ ν•΄μ‹ κ°’μΌλ΅ λ°μ΄ν„°λ¥Ό λ§λ“¤μ–΄λ‚Ό μλ” μ—†μµλ‹λ‹¤. λ‹¨λ°©ν–¥ μ•”νΈν™” μ•κ³ λ¦¬μ¦μ΄λΌκ³ λ„ ν•λ©° ν¨μ¤μ›λ“λ¥Ό μ €μ¥ν•  λ• μ‚¬μ©ν•©λ‹λ‹¤.
- λ€μΉ­ν‚¤ μ•κ³ λ¦¬μ¦(Symmetric-key algorithm): AES, DES, RC4 λ“±μ΄ μμΌλ©° μ•”νΈν™”ν•λ” ν‚¤μ™€ λ³µνΈν™”ν•λ” ν‚¤κ°€ λ™μΌν•©λ‹λ‹¤.
- κ³µκ°ν‚¤ μ•κ³ λ¦¬μ¦(Public key infrastructure, PKI): RSAκ°€ λ€ν‘μ μ΄λ©° μ•”νΈν™”ν•λ” ν‚¤μ™€ λ³µνΈν™”ν•λ” ν‚¤κ°€ λ‹¤λ¦…λ‹λ‹¤. μ•”νΈν™”ν•λ” ν‚¤λ” κ³µκ° ν‚¤λΌκ³  ν•μ—¬ μ™Έλ¶€μ— κ³µκ°ν•κ³ , λ³µνΈν™”ν•λ” ν‚¤λ” λΉ„λ°€ ν‚¤(κ°μΈ ν‚¤)λΌκ³ ν•μ—¬ μ™Έλ¶€μ— λ…Έμ¶ν•μ§€ μ•μµλ‹λ‹¤. κ³µκ° ν‚¤λ΅λ” λΉ„λ°€ ν‚¤λ¥Ό λ§λ“¤μ–΄λ‚΄κΈ° νλ“¤λ„λ΅ μ„¤κ³„λμ–΄ μμµλ‹λ‹¤.
ν•΄μ‹ μ•κ³ λ¦¬μ¦ μ‚¬μ©ν•κΈ°
λ‹¤μμ€ crypto/sha512 ν¨ν‚¤μ§€μ—μ„ μ κ³µν•λ” ν•΄μ‹ μ•κ³ λ¦¬μ¦ ν•¨μμ…λ‹λ‹¤.

- func New() hash.Hash: SHA512 ν•΄μ‹ μΈμ¤ν„΄μ¤ μƒμ„±
- func Sum512(data []byte) [Size]byte: SHA512 ν•΄μ‹λ¥Ό κ³„μ‚°ν•μ—¬ λ¦¬ν„΄
- func (d *digest) Write(p []byte) (nn int, err error): ν•΄μ‹ μΈμ¤ν„΄μ¤μ— λ°μ΄ν„° μ¶”κ°€
- func (d0 *digest) Sum(in []byte) []byte: ν•΄μ‹ μΈμ¤ν„΄μ¤μ— μ €μ¥λ λ°μ΄ν„°μ SHA512 ν•΄μ‹ κ°’ μ¶”μ¶
SHA512 μ•κ³ λ¦¬μ¦μ„ μ‚¬μ©ν•μ—¬ λ°μ΄ν„°μ—μ„ ν•΄μ‹ κ°’μ„ μ¶”μ¶ν•΄λ³΄κ² μµλ‹λ‹¤.

```
package main

import (
	"crypto/sha512"
	"fmt"
)

func main() {
	s := "Hello, world!"
	h1 := sha512.Sum512([]byte(s)) // λ¬Έμμ—΄μ SHA512 ν•΄μ‹ κ°’ μ¶”μ¶
	fmt.Printf("%x\n", h1)

	sha := sha512.New()          // SHA512 ν•΄μ‹ μΈμ¤ν„΄μ¤ μƒμ„±
	sha.Write([]byte("Hello, ")) // ν•΄μ‹ μΈμ¤ν„΄μ¤μ— λ°μ΄ν„° μ¶”κ°€
	sha.Write([]byte("world!"))  // ν•΄μ‹ μΈμ¤ν„΄μ¤μ— λ°μ΄ν„° μ¶”κ°€
	h2 := sha.Sum(nil)           // ν•΄μ‹ μΈμ¤ν„΄μ¤μ— μ €μ¥λ λ°μ΄ν„°μ SHA512 ν•΄μ‹ κ°’ μ¶”μ¶
	fmt.Printf("%x\n", h2)
}
```

```
c1527cd893c124773d811911970c8fe6e857d6df5dc9226bd8a160614c0cd963a4ddea2b94bb7d36021ef9d865d5cea294a82dd49a0bb269f51f6e7a57f79421
c1527cd893c124773d811911970c8fe6e857d6df5dc9226bd8a160614c0cd963a4ddea2b94bb7d36021ef9d865d5cea294a82dd49a0bb269f51f6e7a57f79421
```

SHA512 ν•΄μ‹ κ°’μ„ μ¶”μ¶ν•λ” λ°©λ²•μ€ κ°„λ‹¨ν•©λ‹λ‹¤. sha512.Sum512 ν•¨μμ— []byte ν•μ‹μΌλ΅ λ°μ΄ν„°λ¥Ό λ„£μ–΄μ£Όλ©΄ ν•΄μ‹ κ°’μ΄ λ¦¬ν„΄λ©λ‹λ‹¤.

sha512.New ν•¨μλ¥Ό μ‚¬μ©ν•μ—¬ μƒλ΅μ΄ μΈμ¤ν„΄μ¤λ¥Ό μƒμ„±ν•μ€λ‹¤λ©΄ Write ν•¨μλ΅ λ°μ΄ν„°λ¥Ό λ„£μ€ λ’¤ Sum ν•¨μλ΅ ν•΄μ‹ κ°’μ„ λ§λ“¤λ©΄ λ©λ‹λ‹¤. μ΄λ• Sum ν•¨μμ—λ” nilμ„ λ„£μ–΄μ¤λ‹λ‹¤.


## π’―AES λ€μΉ­ν‚¤ μ•κ³ λ¦¬μ¦ μ‚¬μ©ν•κΈ°
λ‹¤μμ€ crypto/aes ν¨ν‚¤μ§€μ—μ„ μ κ³µν•λ” λ€μΉ­ν‚¤ μ•κ³ λ¦¬μ¦ ν•¨μμ…λ‹λ‹¤.

- func NewCipher(key []byte) (cipher.Block, error): λ€μΉ­ν‚¤ μ•”νΈν™” λΈ”λ΅ μƒμ„±
- func (c *aesCipher) Encrypt(dst, src []byte): ν‰λ¬Έμ„ AES μ•κ³ λ¦¬μ¦μΌλ΅ μ•”νΈν™”
- func (c *aesCipher) Decrypt(dst, src []byte): AES μ•κ³ λ¦¬μ¦μΌλ΅ μ•”νΈν™”λ λ°μ΄ν„°λ¥Ό ν‰λ¬ΈμΌλ΅ λ³µνΈν™”
μ΄λ²μ—λ” AES λ€μΉ­ν‚¤ μ•κ³ λ¦¬μ¦μ„ μ‚¬μ©ν•μ—¬ λ°μ΄ν„°λ¥Ό μ•”νΈν™”ν•κ³  λ³µνΈν™”ν•΄λ³΄κ² μµλ‹λ‹¤.
```
package main

import (
	"crypto/aes"
	"fmt"
)

func main() {
	key := "Hello, Key 12345" // 16λ°”μ΄νΈ
	s := "Hello, world! 12"   // 16λ°”μ΄νΈ

	block, err := aes.NewCipher([]byte(key)) // AES λ€μΉ­ν‚¤ μ•”νΈν™” λΈ”λ΅ μƒμ„±
	if err != nil {
		fmt.Println(err)
		return
	}

	ciphertext := make([]byte, len(s))
	block.Encrypt(ciphertext, []byte(s)) // ν‰λ¬Έμ„ AES μ•κ³ λ¦¬μ¦μΌλ΅ μ•”νΈν™”
	fmt.Printf("%x\n", ciphertext)

	plaintext := make([]byte, len(s))
	block.Decrypt(plaintext, ciphertext) // AES μ•κ³ λ¦¬μ¦μΌλ΅ μ•”νΈν™”λ λ°μ΄ν„°λ¥Ό ν‰λ¬ΈμΌλ΅ λ³µνΈν™”
	fmt.Println(string(plaintext))
}
```
```
a20455c66b97529fa756a0c9a7d2f329
Hello, world! 12
```

AESλ” λΈ”λ΅ μ•”νΈν™” μ•κ³ λ¦¬μ¦μ΄λ―€λ΅ ν‚¤μ™€ μ•”νΈν™”ν•  λ°μ΄ν„°μ ν¬κΈ°κ°€ μΌμ •ν•΄μ•Ό ν•©λ‹λ‹¤. μ—¬κΈ°μ„λ” ν‚¤μ™€ λ°μ΄ν„° λ¨λ‘ 16λ°”μ΄νΈλ΅ λ§λ“¤μ—μµλ‹λ‹¤.

aes.NewCipher ν•¨μμ— ν‚¤λ¥Ό λ„£μΌλ©΄ μ•”νΈν™” λΈ”λ΅(cipher.Block)μ΄ λ¦¬ν„΄λ©λ‹λ‹¤. κ·Έλ¦¬κ³  Encrypt ν•¨μμ— λ°μ΄ν„°(s)μ™€ μ•”νΈν™”λ λ°μ΄ν„°μ„ μ €μ¥ν•  μ¬λΌμ΄μ¤(ciphertext)λ¥Ό λ„£μΌλ©΄ μ•”νΈν™”κ°€ λ©λ‹λ‹¤. λ§μ°¬κ°€μ§€λ΅ Decrypt ν•¨μμ— μ•”νΈν™”λ λ°μ΄ν„°μ™€ λ³µνΈν™”λ λ°μ΄ν„°λ¥Ό μ €μ¥ν•  μ¬λΌμ΄μ¤λ¥Ό λ„£μΌλ©΄ λ³µνΈν™”κ°€ λ©λ‹λ‹¤.


κΈ΄ λ°μ΄ν„°λ¥Ό μ•μ „ν•κ² μ•”νΈν™”ν•κΈ° μ„ν•΄ λ€μΉ­ν‚¤ μ•κ³ λ¦¬μ¦μ€ λ‹¤μ–‘ν• μ΄μ© λ°©μ‹μ„ μ κ³µν•©λ‹λ‹¤. κ·Έμ¤‘ CBC(Cipher Block Chaining) λ°©μ‹μ„ μ‚¬μ©ν•μ—¬ μ•”νΈν™”λ¥Ό ν•΄λ³΄κ² μµλ‹λ‹¤.

λ‹¤μμ€ crypto/cipher ν¨ν‚¤μ§€μ—μ„ μ κ³µν•λ” μ•”νΈν™” μ΄μ© λ¨λ“ ν•¨μμ…λ‹λ‹¤.

- func NewCBCEncrypter(b Block, iv []byte) BlockMode: μ•”νΈν™” λΈ”λ΅κ³Ό μ΄κΈ°ν™” λ²΅ν„°λ΅ μ•”νΈν™” λΈ”λ΅ λ¨λ“ μΈμ¤ν„΄μ¤ μƒμ„±
- func (x *cbcEncrypter) CryptBlocks(dst, src []byte): μ•”νΈν™” λΈ”λ΅ λ¨λ“ μΈμ¤ν„΄μ¤λ΅ μ•”νΈν™”
- func NewCBCDecrypter(b Block, iv []byte) BlockMode: μ•”νΈν™” λΈ”λ΅κ³Ό μ΄κΈ°ν™” λ²΅ν„°λ΅ λ³µνΈν™” λΈ”λ΅ λ¨λ“ μΈμ¤ν„΄μ¤ μƒμ„±
- func (x *cbcDecrypter) CryptBlocks(dst, src []byte): λ³µνΈν™” λΈ”λ΅ λ¨λ“ μΈμ¤ν„΄μ¤λ΅ λ³µνΈν™”
λ‹¤μμ€ io ν¨ν‚¤μ§€μ—μ„ μ κ³µν•λ” μ½κΈ° ν•¨μμ…λ‹λ‹¤.

- func ReadFull(r Reader, buf []byte) (n int, err error): io.Readerμ—μ„ bufμ κΈΈμ΄λ§νΌ λ°μ΄ν„°λ¥Ό μ½μ

```
package main

import (
	"crypto/aes"
	"crypto/cipher"
	"crypto/rand"
	"fmt"
	"io"
)

func encrypt(b cipher.Block, plaintext []byte) []byte {
	if mod := len(plaintext) % aes.BlockSize; mod != 0 { // λΈ”λ΅ ν¬κΈ°μ λ°°μκ°€ λμ–΄μ•Όν•¨
		padding := make([]byte, aes.BlockSize-mod)   // λΈ”λ΅ ν¬κΈ°μ—μ„ λ¨μλΌλ” λ¶€λ¶„μ„
		plaintext = append(plaintext, padding...)    // μ±„μ›μ¤
	}

	ciphertext := make([]byte, aes.BlockSize+len(plaintext)) // μ΄κΈ°ν™” λ²΅ν„° κ³µκ°„(aes.BlockSize)λ§νΌ λ” μƒμ„±
	iv := ciphertext[:aes.BlockSize] // λ¶€λ¶„ μ¬λΌμ΄μ¤λ΅ μ΄κΈ°ν™” λ²΅ν„° κ³µκ°„μ„ κ°€μ Έμ΄
	if _, err := io.ReadFull(rand.Reader, iv); err != nil { // λλ¤ κ°’μ„ μ΄κΈ°ν™” λ²΅ν„°μ— λ„£μ–΄μ¤
		fmt.Println(err)
		return nil
	}

	mode := cipher.NewCBCEncrypter(b, iv) // μ•”νΈν™” λΈ”λ΅κ³Ό μ΄κΈ°ν™” λ²΅ν„°λ¥Ό λ„£μ–΄μ„ μ•”νΈν™” λΈ”λ΅ λ¨λ“ μΈμ¤ν„΄μ¤ μƒμ„±
	mode.CryptBlocks(ciphertext[aes.BlockSize:], plaintext) // μ•”νΈν™” λΈ”λ΅ λ¨λ“ μΈμ¤ν„΄μ¤λ΅
                                                                // μ•”νΈν™”

	return ciphertext
}

func decrypt(b cipher.Block, ciphertext []byte) []byte {
	if len(ciphertext)%aes.BlockSize != 0 { // λΈ”λ΅ ν¬κΈ°μ λ°°μκ°€ μ•„λ‹λ©΄ λ¦¬ν„΄
		fmt.Println("μ•”νΈν™”λ λ°μ΄ν„°μ κΈΈμ΄λ” λΈ”λ΅ ν¬κΈ°μ λ°°μκ°€ λμ–΄μ•Όν•©λ‹λ‹¤.")
		return nil
	}

	iv := ciphertext[:aes.BlockSize]        // λ¶€λ¶„ μ¬λΌμ΄μ¤λ΅ μ΄κΈ°ν™” λ²΅ν„° κ³µκ°„μ„ κ°€μ Έμ΄
	ciphertext = ciphertext[aes.BlockSize:] // λ¶€λ¶„ μ¬λΌμ΄μ¤λ΅ μ•”νΈν™”λ λ°μ΄ν„°λ¥Ό κ°€μ Έμ΄

	plaintext := make([]byte, len(ciphertext)) // ν‰λ¬Έ λ°μ΄ν„°λ¥Ό μ €μ¥ν•  κ³µκ°„ μƒμ„±
	mode := cipher.NewCBCDecrypter(b, iv)      // μ•”νΈν™” λΈ”λ΅κ³Ό μ΄κΈ°ν™” λ²΅ν„°λ¥Ό λ„£μ–΄μ„
                                                   // λ³µνΈν™” λΈ”λ΅ λ¨λ“ μΈμ¤ν„΄μ¤ μƒμ„±
	mode.CryptBlocks(plaintext, ciphertext)    // λ³µνΈν™” λΈ”λ΅ λ¨λ“ μΈμ¤ν„΄μ¤λ΅ λ³µνΈν™”

	return plaintext
}

func main() {
	key := "Hello Key 123456" // 16λ°”μ΄νΈ

	s := `λ™ν•΄ λ¬Όκ³Ό λ°±λ‘μ‚°μ΄ λ§λ¥΄κ³  λ‹³λ„λ΅
ν•λλ‹μ΄ λ³΄μ°ν•μ‚¬ μ°λ¦¬λ‚λΌ λ§μ„Έ.
λ¬΄κ¶ν™” μ‚Όμ²λ¦¬ ν™”λ ¤κ°•μ‚°
λ€ν• μ‚¬λ, λ€ν•μΌλ΅ κΈΈμ΄ λ³΄μ „ν•μ„Έ.`

	block, err := aes.NewCipher([]byte(key)) // AES λ€μΉ­ν‚¤ μ•”νΈν™” λΈ”λ΅ μƒμ„±
	if err != nil {
		fmt.Println(err)
		return
	}

	ciphertext := encrypt(block, []byte(s)) // ν‰λ¬Έμ„ AES μ•κ³ λ¦¬μ¦μΌλ΅ μ•”νΈν™”
	fmt.Printf("%x\n", ciphertext)

	plaintext := decrypt(block, ciphertext) // AES μ•κ³ λ¦¬μ¦ μ•”νΈλ¬Έμ„ ν‰λ¬ΈμΌλ΅ λ³µνΈν™”
	fmt.Println(string(plaintext))

}
```
```
6b39496c974990a9890f49ec962f92cd00f3009f724e3e6a7bcdd7b37867... (μƒλµ)
λ™ν•΄ λ¬Όκ³Ό λ°±λ‘μ‚°μ΄ λ§λ¥΄κ³  λ‹³λ„λ΅... (μƒλµ)
```
λ¨Όμ € λΈ”λ΅ μ•”νΈν™”λ” μ•”νΈν™”ν•  λ°μ΄ν„°μ κΈΈμ΄κ°€ λΈ”λ΅ ν¬κΈ°(aes.BlockSize)μ λ°°μλΌμ•Ό ν•©λ‹λ‹¤. λ”°λΌμ„ λ‹¤μκ³Ό κ°™μ΄ λΈ”λ΅ ν¬κΈ°μ λ°°μκ°€ λ  μ μλ„λ΅ λ¨μλΌλ” λ¶€λ¶„μ„ μ±„μ›μ¤λ‹λ‹¤.

```
if mod := len(plaintext) % aes.BlockSize; mod != 0 { // λΈ”λ΅ ν¬κΈ°μ λ°°μκ°€ λμ–΄μ•Όν•¨
	padding := make([]byte, aes.BlockSize-mod)   // λΈ”λ΅ ν¬κΈ°μ—μ„ λ¨μλΌλ” λ¶€λ¶„μ„
	plaintext = append(plaintext, padding...)    // μ±„μ›μ¤
}
```
CBC μ΄μ© λ°©μ‹μ€ μ΄κΈ°ν™” λ²΅ν„°(Initialization Vector, IV)λ¥Ό μ²« λΈ”λ΅μ— λ°°μΉμ‹ν‚¤κ³ , κ° λΈ”λ΅μ€ μ΄μ „ λΈ”λ΅μ μ•”νΈν™” κ²°κ³Όμ™€ XORλ©λ‹λ‹¤. λ”°λΌμ„ μ΄κΈ°ν™” λ²΅ν„°λ” μ•”νΈν™”ν•  λ•λ§λ‹¤ λ§¤λ² λ‹¤λ¥Έ κ°’μΌλ΅ μƒμ„±ν•΄μ•Ό ν•©λ‹λ‹¤.
```
ciphertext := make([]byte, aes.BlockSize+len(plaintext)) // μ΄κΈ°ν™” λ²΅ν„° κ³µκ°„(aes.BlockSize)λ§νΌ λ” μƒμ„±
iv := ciphertext[:aes.BlockSize] // λ¶€λ¶„ μ¬λΌμ΄μ¤λ΅ μ΄κΈ°ν™” λ²΅ν„° κ³µκ°„μ„ κ°€μ Έμ΄
if _, err := io.ReadFull(rand.Reader, iv); err != nil { // λλ¤ κ°’μ„ μ΄κΈ°ν™” λ²΅ν„°μ— λ„£μ–΄μ¤
	fmt.Println(err)
	return nil
}
```
μ•”νΈν™” λ°μ΄ν„°λ¥Ό μ €μ¥ν•  μ¬λΌμ΄μ¤λ” μ΄κΈ°ν™” λ²΅ν„°κ°€ λ“¤μ–΄κ° κ³µκ°„(aes.BlockSize)λ§νΌ λ” μƒμ„±ν•΄μ¤λ‹λ‹¤. κ·Έλ¦¬κ³  rand.Readerλ¥Ό io.ReadFull ν•¨μλ΅ μ½μΌλ©΄ λλ¤ κ°’μ„ μ–»μ„ μ μμµλ‹λ‹¤. μ΄ λλ¤ κ°’μ„ μ΄κΈ°ν™” λ²΅ν„° ivμ— λ„£μ–΄μ¤λ‹λ‹¤.

cipher.NewCBCEncrypter ν•¨μμ— μ•”νΈν™” λΈ”λ΅ bμ™€ μ΄κΈ°ν™” λ²΅ν„° ivλ¥Ό λ„£μ–΄μ¤€ λ’¤ CryptBlocks ν•¨μλ΅ μ•”νΈν™”λ¥Ό ν•λ©΄ λ©λ‹λ‹¤.
```
mode := cipher.NewCBCEncrypter(b, iv) // μ•”νΈν™” λΈ”λ΅κ³Ό μ΄κΈ°ν™” λ²΅ν„°λ¥Ό λ„£μ–΄μ„ μ•”νΈν™” λΈ”λ΅ λ¨λ“ μΈμ¤ν„΄μ¤ μƒμ„±
mode.CryptBlocks(ciphertext[aes.BlockSize:], plaintext) // μ•”νΈν™” λΈ”λ΅ λ¨λ“ μΈμ¤ν„΄μ¤λ΅ μ•”νΈν™”

```
μ΄λ²μ—λ” λ³µνΈν™”λ¥Ό μ•μ•„λ³΄κ² μµλ‹λ‹¤. λ³µνΈν™”λ¥Ό ν•  λ• μ•”νΈν™”λ λ°μ΄ν„°μ κΈΈμ΄λ” λΈ”λ΅ ν¬κΈ°μ λ°°μκ°€ λμ–΄μ•Ό ν•©λ‹λ‹¤. λ”°λΌμ„ λ³µνΈν™”ν•κΈ° μ „μ— ν•­μƒ κΈΈμ΄λ¥Ό κ²€μ‚¬ν•©λ‹λ‹¤.
```
if len(ciphertext)%aes.BlockSize != 0 { // λΈ”λ΅ ν¬κΈ°μ λ°°μκ°€ μ•„λ‹λ©΄ λ¦¬ν„΄
	fmt.Println("μ•”νΈν™”λ λ°μ΄ν„°μ κΈΈμ΄λ” λΈ”λ΅ ν¬κΈ°μ λ°°μκ°€ λμ–΄μ•Όν•©λ‹λ‹¤.")
	return nil
}
```
μ•”νΈν™”λ λ°μ΄ν„°(ciphertext)μ μ²« λΈ”λ΅μ—μ„ ivλ¥Ό κΊΌλƒ…λ‹λ‹¤. κ·Έλ¦¬κ³  cipher.NewCBCDecrypter ν•¨μμ— μ•”νΈν™” λΈ”λ΅ bμ™€ μ΄κΈ°ν™” λ²΅ν„° ivλ¥Ό λ„£μ–΄μ¤€ λ’¤ CryptBlocks ν•¨μλ΅ λ³µνΈν™”λ¥Ό ν•λ©΄ λ©λ‹λ‹¤.
```
iv := ciphertext[:aes.BlockSize]        // λ¶€λ¶„ μ¬λΌμ΄μ¤λ΅ μ΄κΈ°ν™” λ²΅ν„° κ³µκ°„μ„ κ°€μ Έμ΄
ciphertext = ciphertext[aes.BlockSize:] // λ¶€λ¶„ μ¬λΌμ΄μ¤λ΅ μ•”νΈν™”λ λ°μ΄ν„°λ¥Ό κ°€μ Έμ΄

plaintext := make([]byte, len(ciphertext)) // ν‰λ¬Έ λ°μ΄ν„°λ¥Ό μ €μ¥ν•  κ³µκ°„ μƒμ„±
mode := cipher.NewCBCDecrypter(b, iv)      // μ•”νΈν™” λΈ”λ΅κ³Ό μ΄κΈ°ν™” λ²΅ν„°λ¥Ό λ„£μ–΄μ„
                                           // λ³µνΈν™” λΈ”λ΅ λ¨λ“ μΈμ¤ν„΄μ¤ μƒμ„±
mode.CryptBlocks(plaintext, ciphertext)    // λ³µνΈν™” λΈ”λ΅ λ¨λ“ μΈμ¤ν„΄μ¤λ΅ λ³µνΈν™”
```
## π’―RSA κ³µκ°ν‚¤ μ•κ³ λ¦¬μ¦ μ‚¬μ©ν•κΈ°
λ€μΉ­ν‚¤ μ•κ³ λ¦¬μ¦μ€ μ•”νΈ ν‚¤κ°€ μ μ¶λλ©΄ μ•”νΈν™”λ λ°μ΄ν„°λ¥Ό λ¨λ‘ ν’€ μ μμµλ‹λ‹¤. νΉν λ„¤νΈμ›ν¬λ΅ μ•”νΈ ν‚¤λ¥Ό μ£Όκ³  λ°›μΌλ©΄ λ…Έμ¶λ  μ„ν—μ΄ μ»¤μ§‘λ‹λ‹¤. λ”°λΌμ„ λ„¤νΈμ›ν¬λ΅ λ°μ΄ν„°λ¥Ό μ£Όκ³  λ°›μ„λ•λ” κ³µκ°ν‚¤ μ•”νΈν™” μ•κ³ λ¦¬μ¦μ„ λ§μ΄ μ‚¬μ©ν•©λ‹λ‹¤. λ‹¨ κ³µκ°ν‚¤ μ•κ³ λ¦¬μ¦μ€ λ€μΉ­ν‚¤ μ•κ³ λ¦¬μ¦μ— λΉ„ν•΄ μ†λ„κ°€ λλ¦¬λ―€λ΅ λ€μΉ­ν‚¤ μ•κ³ λ¦¬μ¦μ μ•”νΈ ν‚¤λ§ κ³µκ°ν‚¤ μ•κ³ λ¦¬μ¦μΌλ΅ μ•”νΈν™”ν•μ—¬ λ„¤νΈμ›ν¬λ΅ μ „μ†΅ν•κΈ°λ„ ν•©λ‹λ‹¤.

λ‹¤μμ€ crypto/rsa ν¨ν‚¤μ§€μ—μ„ μ κ³µν•λ” κ³µκ°ν‚¤ μ•κ³ λ¦¬μ¦ ν•¨μμ…λ‹λ‹¤.

- func GenerateKey(random io.Reader, bits int) (priv *PrivateKey, err error): κ°μΈ ν‚¤μ™€ κ³µκ°ν‚¤ μƒμ„±
- func EncryptPKCS1v15(rand io.Reader, pub *PublicKey, msg []byte) (out []byte, err error): ν‰λ¬Έμ„ κ³µκ° ν‚¤λ΅ μ•”νΈν™”
- func DecryptPKCS1v15(rand io.Reader, priv *PrivateKey, ciphertext []byte) (out []byte, err error): μ•”νΈν™”λ λ°μ΄ν„°λ¥Ό κ°μΈ ν‚¤λ΅ λ³µνΈν™”
RSA κ³µκ°ν‚¤ μ•κ³ λ¦¬μ¦μ„ μ‚¬μ©ν•μ—¬ μ•”νΈν™”μ™€ λ³µνΈν™”λ¥Ό ν•΄λ³΄κ² μµλ‹λ‹¤.
```
package main

import (
	"crypto/rand"
	"crypto/rsa"
	"fmt"
)

func main() {
	privateKey, err := rsa.GenerateKey(rand.Reader, 2048) // κ°μΈ ν‚¤μ™€ κ³µκ°ν‚¤ μƒμ„±
	if err != nil {
		fmt.Println(err)
		return
	}
	publicKey := &privateKey.PublicKey // κ°μΈ ν‚¤ λ³€μ μ•μ— κ³µκ° ν‚¤κ°€ λ“¤μ–΄μμ

	s := `λ™ν•΄ λ¬Όκ³Ό λ°±λ‘μ‚°μ΄ λ§λ¥΄κ³  λ‹³λ„λ΅
ν•λλ‹μ΄ λ³΄μ°ν•μ‚¬ μ°λ¦¬λ‚λΌ λ§μ„Έ.
λ¬΄κ¶ν™” μ‚Όμ²λ¦¬ ν™”λ ¤κ°•μ‚°
λ€ν• μ‚¬λ, λ€ν•μΌλ΅ κΈΈμ΄ λ³΄μ „ν•μ„Έ.`

	ciphertext, err := rsa.EncryptPKCS1v15( // ν‰λ¬Έμ„ κ³µκ° ν‚¤λ΅ μ•”νΈν™”
		rand.Reader,
		publicKey, // κ³µκ°ν‚¤
		[]byte(s),
	)

	fmt.Printf("%x\n", ciphertext)

	plaintext, err := rsa.DecryptPKCS1v15( // μ•”νΈν™”λ λ°μ΄ν„°λ¥Ό κ°μΈ ν‚¤λ΅ λ³µνΈν™”
		rand.Reader,
		privateKey, // κ°μΈν‚¤
		ciphertext,
	)

	fmt.Println(string(plaintext))
}
```
rsa.GenerateKey ν•¨μμ— rand.Readerμ™€ ν‚¤μ κΈΈμ΄λ¥Ό λ„£μΌλ©΄ κ°μΈ ν‚¤μ™€ κ³µκ°ν‚¤κ°€ μƒμ„±λ©λ‹λ‹¤. ν‚¤μ κΈΈμ΄λ” λΉ„νΈ λ‹¨μ„μ΄λ©° 2μ μ κ³±μΌλ΅ μ…λ ¥ν•©λ‹λ‹¤.
rsa.EncryptPKCS1v15 ν•¨μμ— rand.Reader, publicKey, μ•”νΈν™”ν•  λ°μ΄ν„°λ¥Ό λ„£μΌλ©΄ μ•”νΈν™”κ°€ λ©λ‹λ‹¤. κ·Έλ¦¬κ³  rsa.DecryptPKCS1v15 ν•¨μμ— rand.Reader, privateKey, μ•”νΈν™”λ λ°μ΄ν„°λ¥Ό λ„£μΌλ©΄ λ³µνΈν™”κ°€ λ©λ‹λ‹¤.

μ΄μ²λΌ κ³µκ°ν‚¤ μ•κ³ λ¦¬μ¦μ€ μ•”νΈν™”ν•  λ•λ” κ³µκ° ν‚¤λ¥Ό μ‚¬μ©ν•κ³ , λ³µνΈν™”ν•  λ•λ” κ°μΈ ν‚¤λ¥Ό μ‚¬μ©ν•©λ‹λ‹¤. κ³µκ° ν‚¤λ¥Ό μ™Έλ¶€μ— κ³µκ°ν•μ—¬ λ‹¤λ¥Έ μ‚¬λν•ν… μ „λ‹¬ν• λ’¤ μ•”νΈν™”λ¥Ό ν•κ³ , μ•”νΈν™”λ λ°μ΄ν„°λ¥Ό λ°›λ” μ‚¬λμ€ μκΈ°κ°€ κ°€μ§„ κ°μΈν‚¤λ΅ λ³µνΈν™”ν•λ” λ°©μ‹μ…λ‹λ‹¤. κ°μΈ ν‚¤λ” μ™Έλ¶€μ— λ…Έμ¶ν•  μΌμ΄ μ—†μΌλ©° κ³µκ° ν‚¤λ΅λ” κ°μΈ ν‚¤λ¥Ό μ¶”μ¶ν•κΈ° μ–΄λ µκΈ° λ•λ¬Έμ— μ•μ „ν•κ² μ•”νΈν™”λ λ°μ΄ν„°λ¥Ό μ£Όκ³  λ°›μ„ μ μμµλ‹λ‹¤.

μ΄λ²μ—λ” RSA μ•κ³ λ¦¬μ¦μ„ μ‚¬μ©ν•μ—¬ λ©”μ‹μ§€λ¥Ό μ„λ…(Signing)ν•κ³  μΈμ¦(Verification)ν•λ” λ°©λ²•μ„ μ•μ•„λ³΄κ² μµλ‹λ‹¤.

λ‹¤μμ€ crypto/rsa ν¨ν‚¤μ§€μ—μ„ μ κ³µν•λ” μ„λ…, μΈμ¦ ν•¨μμ…λ‹λ‹¤.

- func SignPKCS1v15(rand io.Reader, priv *PrivateKey, hash crypto.Hash, hashed []byte) (s []byte, err error): κ°μΈ ν‚¤λ΅ μ„λ…
- func VerifyPKCS1v15(pub *PublicKey, hash crypto.Hash, hashed []byte, sig []byte) (err error): κ³µκ°ν‚¤λ΅ μ„λ… κ²€μ¦
λ‹¤μμ€ crypto/md5 ν¨ν‚¤μ§€μ—μ„ μ κ³µν•λ” ν•΄μ‹ ν•¨μμ…λ‹λ‹¤.

- func New() hash.Hash: MD5 ν•΄μ‹ μΈμ¤ν„΄μ¤ μƒμ„±
- func (d *digest) Write(p []byte) (nn int, err error): ν•΄μ‹ μΈμ¤ν„΄μ¤μ— λ°μ΄ν„° μ¶”κ°€
- func (d0 *digest) Sum(in []byte) []byte: ν•΄μ‹ μΈμ¤ν„΄μ¤μ— μ €μ¥λ λ°μ΄ν„°μ MD5 ν•΄μ‹ κ°’ μ¶”μ¶

```
package main

import (
	"crypto"
	"crypto/md5"
	"crypto/rand"
	"crypto/rsa"
	"fmt"
)

func main() {
	privateKey, err := rsa.GenerateKey(rand.Reader, 2048) // κ°μΈ ν‚¤μ™€ κ³µκ° ν‚¤ μƒμ„±
	if err != nil {
		fmt.Println(err)
		return
	}
	publicKey := &privateKey.PublicKey // κ°μΈ ν‚¤ λ³€μ μ•μ— κ³µκ° ν‚¤κ°€ λ“¤μ–΄μμ

	message := "μ•λ…•ν•μ„Έμ”. Go μ–Έμ–΄"
	hash := md5.New()           // ν•΄μ‹ μΈμ¤ν„΄μ¤ μƒμ„±
	hash.Write([]byte(message)) // ν•΄μ‹ μΈμ¤ν„΄μ¤μ— λ¬Έμμ—΄ μ¶”κ°€
	digest := hash.Sum(nil)     // λ¬Έμμ—΄μ MD5 ν•΄μ‹ κ°’ μ¶”μ¶

	var h1 crypto.Hash
	signature, err := rsa.SignPKCS1v15( // κ°μΈ ν‚¤λ΅ μ„λ…
		rand.Reader,
		privateKey, // κ°μΈ ν‚¤
		h1,
		digest,     // MD5 ν•΄μ‹ κ°’
	)

	var h2 crypto.Hash
	err = rsa.VerifyPKCS1v15( // κ³µκ° ν‚¤λ΅ μ„λ… κ²€μ¦
		publicKey, // κ³µκ° ν‚¤
		h2,
		digest,    // MD5 ν•΄μ‹ κ°’
		signature, // μ„λ… κ°’
	)

	if err != nil {
		fmt.Println("κ²€μ¦ μ‹¤ν¨")
	} else {
		fmt.Println("κ²€μ¦ μ„±κ³µ")
	}
}
```
λ¨Όμ € μ„λ…ν•  λ°μ΄ν„°μ ν•΄μ‹ κ°’μ„ κµ¬ν•©λ‹λ‹¤. μ—¬κΈ°μ„λ” md5λ΅ ν•΄μ‹ κ°’μ„ κµ¬ν•©λ‹λ‹¤.
```
message := "μ•λ…•ν•μ„Έμ”. Go μ–Έμ–΄"
hash := md5.New()           // ν•΄μ‹ μΈμ¤ν„΄μ¤ μƒμ„±
hash.Write([]byte(message)) // ν•΄μ‹ μΈμ¤ν„΄μ¤μ— λ¬Έμμ—΄ μ¶”κ°€
digest := hash.Sum(nil)     // λ¬Έμμ—΄μ MD5 ν•΄μ‹ κ°’ μ¶”μ¶
```
μ΄μ  β€μ•λ…•ν•μ„Έμ”. Go μ–Έμ–΄β€μ ν•΄μ‹ κ°’μ„ κ°μΈ ν‚¤λ΅ μ„λ…ν•©λ‹λ‹¤. μ—¬κΈ°μ„ μ„λ…μ΄λ€ λ‚΄κ°€ β€μ•λ…•ν•μ„Έμ”. Go μ–Έμ–΄β€λΌλ” λ©”μ‹μ§€λ¥Ό λ³΄λƒλ‹¤κ³  λ³΄μ¦ν•λ” κ²ƒμ…λ‹λ‹¤.
```
var h1 crypto.Hash
signature, err := rsa.SignPKCS1v15( // κ°μΈ ν‚¤λ΅ μ„λ…
	rand.Reader,
	privateKey, // κ°μΈ ν‚¤
	h1,
	digest,     // MD5 ν•΄μ‹ κ°’
)
```
rsa.SignPKCS1v15 ν•¨μμ— rand.Reader, crypto.Hash, κ°μΈ ν‚¤, ν•΄μ‹ κ°’μ„ λ„£μΌλ©΄ μ„λ…μ΄ λ©λ‹λ‹¤. μ΄λ ‡κ² ν•΄μ„ λ©”μ‹μ§€(message), λ©”μ‹μ§€μ— λ€ν• ν•΄μ‹ κ°’(digest), μ„λ…(signature)μ΄ λ¨λ‘ μ¤€λΉ„λμ—μµλ‹λ‹¤.

λ©”μ‹μ§€λ¥Ό λ°›λ” μ‚¬λμ€ μ •λ§ μ € μ‚¬λ(κ°μΈ ν‚¤λ¥Ό κ°€μ§„ μ‚¬λ)μ΄ β€μ•λ…•ν•μ„Έμ”. Go μ–Έμ–΄β€λΌλ” λ§μ„ ν–λ”μ§€ κ²€μ¦(μΈμ¦)μ„ ν•΄μ•Όλ©λ‹λ‹¤.
```
var h2 crypto.Hash
err = rsa.VerifyPKCS1v15( // κ³µκ° ν‚¤λ΅ μ„λ… κ²€μ¦
	publicKey, // κ³µκ° ν‚¤
	h2,
	digest,    // MD5 ν•΄μ‹ κ°’
	signature, // μ„λ… κ°’
)
```
rsa.VerifyPKCS1v15 ν•¨μμ— κ³µκ° ν‚¤, crypto.Hash, ν•΄μ‹ κ°’, μ„λ…μ„ λ„£μΌλ©΄ κ²€μ¦μ΄ λ©λ‹λ‹¤. err κ°’μ΄ nilμ΄λ©΄ μ •μƒμ μΈ λ©”μ‹μ§€μ…λ‹λ‹¤.

λ©”μ‹μ§€, λ©”μ‹μ§€μ— λ€ν• ν•΄μ‹ κ°’, μ„λ…, κ³µκ° ν‚¤λ” λ¨λ‘ κ³µκ°λ μ •λ³΄μ…λ‹λ‹¤. μ΄ κ°’λ“¤μ„ μ΄μ©ν•΄μ„ λ©”μ‹μ§€κ°€ λ³€μ΅°λμ§€ μ•κ³ , μ¬λ°”λ¥Έ μ‚¬λν•ν…μ„ μ™”λ”μ§€ κ²€μ¦ν•λ” κ²ƒμ…λ‹λ‹¤.

- λ©”μ‹μ§€μ— λ€ν• ν•΄μ‹ κ°’μΌλ΅ λ©”μ‹μ§€κ°€ λ³€μ΅°λμ—λ”μ§€ ν™•μΈν•  μ μμµλ‹λ‹¤.
- μ„λ… κ°’μΌλ΅ λ©”μ‹μ§€κ°€ μ¬λ°”λ¥Έ μ‚¬λν•ν…μ„ μ™”λ”μ§€ ν™•μΈν•  μ μμµλ‹λ‹¤. μ¦‰ μ„λ…μ„ ν•  μ μλ” μ‚¬λμ€ κ°μΈ ν‚¤λ¥Ό κ°€μ§„ μ‚¬λλ°–μ— μ—†κΈ° λ•λ¬Έμ…λ‹λ‹¤.
κ°μΈ ν‚¤λ¥Ό κ°€μ§€κ³  μ„λ…μ„ ν•λ” μ£Όμ²΄λ” μ‚¬λμ΄ λ  μλ„ μκ³  μ»΄ν“¨ν„°κ°€ λ  μλ„ μμµλ‹λ‹¤. μ—¬κΈ°μ„λ” νΈμμƒ μ‚¬λμ΄λΌ μΉ­ν–μµλ‹λ‹¤. λ³΄ν†µ κΈμµκ±°λμ—μ„ λ§μ΄ μ“°λ” κ³µμΈμΈμ¦μ„κ°€ μ„λ…κ³Ό μΈμ¦ λ°©μ‹μ— RSA μ•κ³ λ¦¬μ¦μ„ μ‚¬μ©ν•©λ‹λ‹¤. λ‹¤λ¥Έ μ‚¬λ΅€λ΅λ” μΈν„°λ„·μ—μ„ νμΌμ„ λ°›μ„ λ• ν•΄μ‹ κ°’κ³Ό μ„λ… νμΌμ΄ ν•¨κ» μλ” κ³³μ΄ μμµλ‹λ‹¤. μ΄λ•λ” ν•΄μ‹ κ°’μΌλ΅ νμΌ λ³€μ΅° μ—¬λ¶€λ¥Ό ν™•μΈν•κ³ , μ„λ… νμΌλ΅ κ³µμ‹ κ°λ°μ(νμ‚¬, λ‹¨μ²΄)κ°€ λ°°ν¬ν• κ²ƒμΈμ§€ κ²€μ¦ν•  μ μμµλ‹λ‹¤.
